(()=>{"use strict";class e{static pressedKeys=new Set;static keysPressedThisFrame=new Set;static keysReleasedThisFrame=new Set;static mousePosition={x:0,y:0};static mouseDelta={x:0,y:0};static init(){window.addEventListener("keydown",(t=>{e.pressedKeys.has(t.code)||e.keysPressedThisFrame.add(t.code),e.pressedKeys.add(t.code)})),window.addEventListener("keyup",(t=>{e.pressedKeys.delete(t.code),e.keysReleasedThisFrame.add(t.code)})),window.addEventListener("mousemove",(t=>{e.mouseDelta.x=t.movementX,e.mouseDelta.y=t.movementY,e.mousePosition.x=t.clientX,e.mousePosition.y=t.clientY})),window.addEventListener("mousedown",(t=>{const i=`Mouse${t.button}`;e.pressedKeys.has(i)||e.keysPressedThisFrame.add(i),e.pressedKeys.add(i)})),window.addEventListener("mouseup",(t=>{const i=`Mouse${t.button}`;e.pressedKeys.delete(i),e.keysReleasedThisFrame.add(i)}))}static clearUpdate(){e.keysPressedThisFrame.clear(),e.keysReleasedThisFrame.clear(),e.mouseDelta.x=0,e.mouseDelta.y=0}static getMousePosition(){return{...this.mousePosition}}static getKeyDown(t){return e.keysPressedThisFrame.has(t)}static getKeyUp(t){return e.keysReleasedThisFrame.has(t)}static getKey(t){return e.pressedKeys.has(t)}}var t="undefined"!=typeof Float32Array?Float32Array:Array;function i(){var e=new t(16);return t!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function n(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function r(e,t,i){var n=t[0],r=t[1],o=t[2],s=t[3],a=t[4],u=t[5],c=t[6],f=t[7],d=t[8],p=t[9],l=t[10],h=t[11],g=t[12],m=t[13],v=t[14],P=t[15],y=i[0],b=i[1],B=i[2],x=i[3];return e[0]=y*n+b*a+B*d+x*g,e[1]=y*r+b*u+B*p+x*m,e[2]=y*o+b*c+B*l+x*v,e[3]=y*s+b*f+B*h+x*P,y=i[4],b=i[5],B=i[6],x=i[7],e[4]=y*n+b*a+B*d+x*g,e[5]=y*r+b*u+B*p+x*m,e[6]=y*o+b*c+B*l+x*v,e[7]=y*s+b*f+B*h+x*P,y=i[8],b=i[9],B=i[10],x=i[11],e[8]=y*n+b*a+B*d+x*g,e[9]=y*r+b*u+B*p+x*m,e[10]=y*o+b*c+B*l+x*v,e[11]=y*s+b*f+B*h+x*P,y=i[12],b=i[13],B=i[14],x=i[15],e[12]=y*n+b*a+B*d+x*g,e[13]=y*r+b*u+B*p+x*m,e[14]=y*o+b*c+B*l+x*v,e[15]=y*s+b*f+B*h+x*P,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var o;function s(){var e=new t(3);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function a(e,i,n){var r=new t(3);return r[0]=e,r[1]=i,r[2]=n,r}function u(e,t){var i=t[0],n=t[1],r=t[2],o=i*i+n*n+r*r;return o>0&&(o=1/Math.sqrt(o)),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e}s(),function(e){e[e.None=0]="None",e[e.Center=1]="Center",e[e.Shell=2]="Shell",e[e.Donut=3]="Donut"}(o||(o={}));class c{static translationMatrix=i();static rotationMatrix=i();static projectionMatrix=i();static yaw=0;static pitch=0;static position=a(0,0,200);static lastMouseX=0;static lastMouseY=0;static paused=!1;static viewMatrix=i();static gravityMode=o.Center;static init(){this.lastMouseX=e.mousePosition.x,this.lastMouseY=e.mousePosition.y,this.updateProjectionMatrix()}static updateProjectionMatrix(){const e=x.canvas.width/x.canvas.height,t=Math.PI/4;!function(e,t,i,n,r){var o,s=1/Math.tan(t/2);e[0]=s/i,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=s,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=r&&r!==1/0?(o=1/(n-r),e[10]=(r+n)*o,e[14]=2*r*n*o):(e[10]=-1,e[14]=-2*n)}(this.projectionMatrix,t,e,.1,3e3)}static update(t){document.pointerLockElement&&(this.yaw+=.002*e.mouseDelta.x,this.pitch+=.002*e.mouseDelta.y,this.pitch=Math.max(-Math.PI/2+.1,Math.min(Math.PI/2-.1,this.pitch)));const i=50*t;var s,u,c,f,d,p,l,h,g,m,v,P,y;e.getKey("KeyW")&&(this.position[0]-=i*Math.sin(-this.yaw),this.position[2]-=i*Math.cos(-this.yaw)),e.getKey("KeyS")&&(this.position[0]+=i*Math.sin(-this.yaw),this.position[2]+=i*Math.cos(-this.yaw)),e.getKey("KeyA")&&(this.position[0]-=i*Math.cos(-this.yaw),this.position[2]+=i*Math.sin(-this.yaw)),e.getKey("KeyD")&&(this.position[0]+=i*Math.cos(-this.yaw),this.position[2]-=i*Math.sin(-this.yaw)),e.getKey("Space")&&(this.position[1]+=i),e.getKey("ShiftLeft")&&(this.position[1]-=i),e.getKeyDown("Mouse0")&&(document.body.requestPointerLock(),this.paused=!1),e.getKeyDown("KeyP")&&(this.paused=!0,document.exitPointerLock()),e.getKeyDown("Digit1")&&(this.gravityMode=o.None),e.getKeyDown("Digit2")&&(this.gravityMode=o.Center),e.getKeyDown("Digit3")&&(this.gravityMode=o.Shell),e.getKeyDown("Digit4")&&(this.gravityMode=o.Donut),n(this.rotationMatrix),s=this.rotationMatrix,u=this.rotationMatrix,c=this.pitch,f=Math.sin(c),d=Math.cos(c),p=u[4],l=u[5],h=u[6],g=u[7],m=u[8],v=u[9],P=u[10],y=u[11],u!==s&&(s[0]=u[0],s[1]=u[1],s[2]=u[2],s[3]=u[3],s[12]=u[12],s[13]=u[13],s[14]=u[14],s[15]=u[15]),s[4]=p*d+m*f,s[5]=l*d+v*f,s[6]=h*d+P*f,s[7]=g*d+y*f,s[8]=m*d-p*f,s[9]=v*d-l*f,s[10]=P*d-h*f,s[11]=y*d-g*f,function(e,t,i){var n=Math.sin(i),r=Math.cos(i),o=t[0],s=t[1],a=t[2],u=t[3],c=t[8],f=t[9],d=t[10],p=t[11];t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*r-c*n,e[1]=s*r-f*n,e[2]=a*r-d*n,e[3]=u*r-p*n,e[8]=o*n+c*r,e[9]=s*n+f*r,e[10]=a*n+d*r,e[11]=u*n+p*r}(this.rotationMatrix,this.rotationMatrix,this.yaw),n(this.translationMatrix),function(e,t,i){var n,r,o,s,a,u,c,f,d,p,l,h,g=i[0],m=i[1],v=i[2];t===e?(e[12]=t[0]*g+t[4]*m+t[8]*v+t[12],e[13]=t[1]*g+t[5]*m+t[9]*v+t[13],e[14]=t[2]*g+t[6]*m+t[10]*v+t[14],e[15]=t[3]*g+t[7]*m+t[11]*v+t[15]):(n=t[0],r=t[1],o=t[2],s=t[3],a=t[4],u=t[5],c=t[6],f=t[7],d=t[8],p=t[9],l=t[10],h=t[11],e[0]=n,e[1]=r,e[2]=o,e[3]=s,e[4]=a,e[5]=u,e[6]=c,e[7]=f,e[8]=d,e[9]=p,e[10]=l,e[11]=h,e[12]=n*g+a*m+d*v+t[12],e[13]=r*g+u*m+p*v+t[13],e[14]=o*g+c*m+l*v+t[14],e[15]=s*g+f*m+h*v+t[15])}(this.translationMatrix,this.translationMatrix,a(-this.position[0],-this.position[1],-this.position[2])),n(this.viewMatrix),r(this.viewMatrix,this.translationMatrix,this.rotationMatrix),r(this.viewMatrix,this.viewMatrix,this.projectionMatrix)}}const f={points:[[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1],[1,0,1],[0,1,1],[1,1,1]],colorIDs:[0,1,2,3,4,5,6,7],connectionIDsBuffers:[[[0,4],[1,5],[2,6],[3,7]],[[0,1],[4,5],[2,3],[6,7]],[[0,2],[1,3],[4,6],[5,7]],[[0,7],[6,1],[3,4],[7,0]]],connectionDistancesBuffers:[[1,1,1,1],[1,1,1,1],[1,1,1,1],[Math.sqrt(3),Math.sqrt(3),Math.sqrt(3),Math.sqrt(3)]]};function d(){var e=new t(4);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function p(e,t,i,n,r){return e[0]=t,e[1]=i,e[2]=n,e[3]=r,e}function l(e,t,i){var n=t[0],r=t[1],o=t[2],s=t[3];return e[0]=i[0]*n+i[4]*r+i[8]*o+i[12]*s,e[1]=i[1]*n+i[5]*r+i[9]*o+i[13]*s,e[2]=i[2]*n+i[6]*r+i[10]*o+i[14]*s,e[3]=i[3]*n+i[7]*r+i[11]*o+i[15]*s,e}d();class h{numPoints;numBuffers;strideByteLength;posByteLength;positionsBuffer;colorsBuffer;connectionPairsBuffers=[];connectionDistanceBuffers=[];connectionBufferSizes=[];centerPosition;boundingBoxMin;boundingBoxMax;isActive;constructor(e,t){this.numPoints=e.points.length,this.posByteLength=3*this.numPoints*4,this.strideByteLength=-1;const i=[],n=d(),r=s();for(let s=0;s<this.numPoints;s++)o=r,a=e.points[s],o[0]=a[0],o[1]=a[1],o[2]=a[2],p(n,r[0],r[1],r[2],1),l(n,n,t),i.push(n[0],n[1],n[2]);var o,a;this.positionsBuffer=x.device.createBuffer({label:"gameobject point buffer",size:3*this.numPoints*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),new Float32Array(this.positionsBuffer.getMappedRange()).set(new Float32Array(i)),this.positionsBuffer.unmap(),this.colorsBuffer=x.device.createBuffer({label:"gameobject color buffer",size:4*this.numPoints,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),new Float32Array(this.colorsBuffer.getMappedRange()).set(new Float32Array(e.colorIDs)),this.colorsBuffer.unmap(),this.numBuffers=e.connectionIDsBuffers.length;for(let t=0;t<this.numBuffers;t++){this.connectionBufferSizes.push(e.connectionIDsBuffers[t].length);const i=x.device.createBuffer({size:2*this.numPoints*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Float32Array(i.getMappedRange()).set(new Float32Array(e.connectionIDsBuffers[t].flat(1))),i.unmap(),this.connectionPairsBuffers.push(i);const n=x.device.createBuffer({size:4*this.numPoints,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Float32Array(n.getMappedRange()).set(new Float32Array(e.connectionDistancesBuffers[t].flat(1))),n.unmap(),this.connectionPairsBuffers.push(n)}this.centerPosition=s(),this.boundingBoxMin=s(),this.boundingBoxMax=s(),this.isActive=!1}}class g{static objects=[];static loadScene0(){for(let n=-5;n<=5;n++)for(let r=-5;r<=5;r++)for(let o=-5;o<=5;o++)this.objects.push(new h(f,(t=[10*n,10*r,10*o],(e=i())[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e)));var e,t}}class m{static NUM_SPHERES=0;static MAX_SPHERES=5e6;static spheresBuffer;static oldSpheresBuffer;static colorIndexBuffer;static atomicBuffer;static gridBuffers=[];static NUM_GRID_BUFFERS=4;static depthTexture;static lightDirection=u(s(),a(0,-1,.5));static init(){this.#e(),this.#t(),this.#i(),this.resize()}static resize(){this.depthTexture&&this.depthTexture.destroy(),this.depthTexture=x.device.createTexture({size:[x.canvas.width,x.canvas.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT})}static loadSceneToBuffers(e){const t=x.device.createCommandEncoder();for(const i of e)i.strideByteLength=12*this.NUM_SPHERES,this.NUM_SPHERES+=i.numPoints,t.copyBufferToBuffer(i.positionsBuffer,0,this.spheresBuffer,i.strideByteLength,i.posByteLength);t.copyBufferToBuffer(this.spheresBuffer,0,this.oldSpheresBuffer,0,12*this.NUM_SPHERES),x.device.queue.submit([t.finish()])}static clearScene(){this.NUM_SPHERES=0,this.resize(),this.init()}static loadDefaultScene(e){this.NUM_SPHERES=e;const t=new Float32Array(3*this.MAX_SPHERES);for(let e=0;e<this.NUM_SPHERES;e++){const i=s();u(i,a(Math.random()-.5,Math.random()-.5,Math.random()-.5)),t[3*e]=i[0]*Math.random()*100,t[3*e+1]=i[1]*Math.random()*100,t[3*e+2]=i[2]*Math.random()*100}x.device.queue.writeBuffer(this.spheresBuffer,0,t),x.device.queue.writeBuffer(this.oldSpheresBuffer,0,t)}static#e(){this.spheresBuffer=x.device.createBuffer({label:"spheres buffer",size:3*this.MAX_SPHERES*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.oldSpheresBuffer=x.device.createBuffer({label:"old spheres buffer",size:3*this.MAX_SPHERES*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST})}static#t(){this.colorIndexBuffer=x.device.createBuffer({label:"color buffer",size:4*this.MAX_SPHERES,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE})}static#i(){const e=134217728;this.atomicBuffer=x.device.createBuffer({label:"atomic buffer",size:e/2,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});for(let t=0;t<this.NUM_GRID_BUFFERS;t++)this.gridBuffers.push(x.device.createBuffer({label:`grid${t} buffer`,size:e,usage:GPUBufferUsage.STORAGE}))}}class v{static computePipeline;static computeBindGroup;static computeBindGroupLayout;static positionsNextBuffer;static computeBindGroup2;static computeBindGroupLayout2;static computePipeline2;static uniformBuffer;static init(){this.positionsNextBuffer=x.device.createBuffer({size:3*m.MAX_SPHERES*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});const e=this.#n();this.computeBindGroupLayout=x.device.createBindGroupLayout({label:"collision bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},...m.gridBuffers.map(((e,t)=>({binding:t+2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}))),{binding:10,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:11,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:12,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),this.uniformBuffer=x.device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),x.device.queue.writeBuffer(this.uniformBuffer,0,new Uint32Array([m.NUM_SPHERES])),this.computePipeline=x.device.createComputePipeline({label:"Collisions compute pipeline",layout:x.device.createPipelineLayout({bindGroupLayouts:[this.computeBindGroupLayout]}),compute:{module:e,entryPoint:"computeMain"}}),this.computeBindGroup=x.device.createBindGroup({label:"ComputeBindGroup 1",layout:this.computeBindGroupLayout,entries:[{binding:0,resource:{buffer:m.spheresBuffer}},{binding:1,resource:{buffer:m.atomicBuffer}},...m.gridBuffers.map(((e,t)=>({binding:t+2,resource:{buffer:e}}))),{binding:10,resource:{buffer:this.positionsNextBuffer}},{binding:11,resource:{buffer:m.colorIndexBuffer}},{binding:12,resource:{buffer:this.uniformBuffer}}]})}static#n(){return x.device.createShaderModule({label:"Collisions compute shader",code:"\n\nstruct Uniforms {\n    numSpheres: u32\n}\n\n@group(0) @binding(0) var<storage, read_write> positions: array<f32>;\n@group(0) @binding(1) var<storage, read> atomicCounter: array<u32>;\n@group(0) @binding(2) var<storage, read> grid1: array<vec2u>;\n@group(0) @binding(3) var<storage, read> grid2: array<vec2u>;\n@group(0) @binding(4) var<storage, read> grid3: array<vec2u>;   \n@group(0) @binding(5) var<storage, read> grid4: array<vec2u>;    \n// @group(0) @binding(6) var<storage, read_write> grid5: array<vec2u>;    \n@group(0) @binding(10) var<storage, read_write> positionsNext: array<f32>;\n@group(0) @binding(11) var<storage, read_write> colors: array<u32>;\n@group(0) @binding(12) var<uniform> uniforms: Uniforms;\n\n\nfn fast_inversesqrt(x: f32) -> f32 {\n    let threehalfs: f32 = 1.5;\n    var y: f32 = x;\n    var i: i32 = bitcast<i32>(y);  // Interpret float as int\n    i = 0x5F3759DF - (i >> 1);      // Magic number and shift\n    y = bitcast<f32>(i);            // Reinterpret int as float\n    y = y * (threehalfs - (0.5 * x * y * y));  // One iteration of Newton's method\n    y = y * (threehalfs - (0.5 * x * y * y));  // 2nd iteration of Newton's method\n    return y;\n}\n\nfn frac_sign(x: f32) -> i32 {\n    let f = x - floor(x);  // Get fractional part\n    return select(1, -1, f < 0.5);\n}\n\n@compute @workgroup_size(256)\nfn computeMain(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sphereID = u32(global_id.x);\n    if (sphereID >= uniforms.numSpheres) {\n        return;\n    }\n    var myPos = vec3f(positions[sphereID*3+0],positions[sphereID*3+1],positions[sphereID*3+2]);\n\n\n    colors[sphereID] = 0u;\n    let spherePos = vec3i(myPos+128);\n    if(spherePos.x<0||spherePos.x>=256||spherePos.y<0||spherePos.y>=256||spherePos.z<0||spherePos.z>=256)\n    {\n        positionsNext[sphereID*3+0] = myPos.x;\n        positionsNext[sphereID*3+1] = myPos.y;\n        positionsNext[sphereID*3+2] = myPos.z;\n        return;\n    }\n    let gridIndex2 = spherePos.x + spherePos.y * 256 + spherePos.z * 65536;\n    // colors[sphereID] = atomicCounter[gridIndex2];\n\n    let neighborOffsets = array<vec3i,8>(\n        vec3i(frac_sign(myPos.x), 0, 0),\n        vec3i(frac_sign(myPos.x), 0, frac_sign(myPos.z)),\n        vec3i(frac_sign(myPos.x), frac_sign(myPos.y), 0),\n        vec3i(0, frac_sign(myPos.y), 0),\n        vec3i(0, frac_sign(myPos.y), frac_sign(myPos.z)),\n        vec3i(0, 0, frac_sign(myPos.z)),\n        vec3i(frac_sign(myPos.x), frac_sign(myPos.y), frac_sign(myPos.z)),\n        vec3i(0,0,0)\n    );\n\n    var countCollisions = 0u;\n    var posCorrection = vec3f(0,0,0);\n\n    let spherePosF = vec3f(\n        positions[sphereID*3+0],\n        positions[sphereID*3+1],\n        positions[sphereID*3+2]\n    );\n\n    for (var i = 0u; i < 8u; i++) {\n        // if(countCollisions>=16) {break;}\n        let neighborPos = vec3i(spherePos+neighborOffsets[i]);\n\n        // Check if the neighbor cell is within grid bounds\n        if (neighborPos.x >= 0 && neighborPos.x < 256 &&\n            neighborPos.y >= 0 && neighborPos.y < 256 &&\n            neighborPos.z >= 0 && neighborPos.z < 256) {\n\n            let gridIndex = u32(neighborPos.x + neighborPos.y * 256 + neighborPos.z * 65536);\n\n            let numSpheres = min(atomicCounter[gridIndex], 8);\n\n\n            var otherSphereID: u32;\n            for (var i = 0u; i < numSpheres; i++) {\n                switch(i / 2u) {\n                    case 0u: {\n                        otherSphereID = grid1[gridIndex][i%2]; break;\n                    }\n                    case 1u: {\n                        otherSphereID = grid2[gridIndex][i%2]; break;\n                    }\n                    case 2u: {\n                        otherSphereID = grid3[gridIndex][i%2]; break;\n                    }\n                    case 3u: {\n                        otherSphereID = grid4[gridIndex][i%2]; break;\n                    }      \n                \n                    default: {\n                        return;\n                    }\n                }\n                \n                if (otherSphereID != sphereID) {\n\n                    let otherPos = vec3f(\n                        positions[otherSphereID*3+0],\n                        positions[otherSphereID*3+1],\n                        positions[otherSphereID*3+2]\n                    );\n\n                    let diff = spherePosF - otherPos;\n                    var dist = dot(diff,diff);\n                    \n                    if (dist < 1) {\n                        countCollisions+=1;\n                        dist = sqrt(dist);\n                        let normal = diff / dist;\n                        let correction =  (1.0 - dist)*0.5;\n                        posCorrection.x += normal.x * correction;\n                        posCorrection.y += normal.y * correction;\n                        posCorrection.z += normal.z * correction;\n                    }\n                }\n            }\n        }\n    }\n    colors[sphereID] = min(countCollisions,15);\n    posCorrection *= 0.125;\n    positionsNext[sphereID*3+0] = myPos.x + posCorrection.x;\n    positionsNext[sphereID*3+1] = myPos.y + posCorrection.y;\n    positionsNext[sphereID*3+2] = myPos.z + posCorrection.z;\n\n}"})}static tick(e){x.device.queue.writeBuffer(this.uniformBuffer,0,new Uint32Array([m.NUM_SPHERES]));const t=e.beginComputePass();t.setPipeline(this.computePipeline),t.setBindGroup(0,this.computeBindGroup),t.dispatchWorkgroups(Math.ceil(m.NUM_SPHERES/256)),t.end(),e.copyBufferToBuffer(this.positionsNextBuffer,0,m.spheresBuffer,0,3*m.NUM_SPHERES*4)}}class P{static computePipeline;static computeBindGroup;static computeBindGroupLayout;static uniformBuffer;static init(){const e=this.#n();this.uniformBuffer=x.device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),x.device.queue.writeBuffer(this.uniformBuffer,0,new Uint32Array([m.NUM_SPHERES])),this.computeBindGroupLayout=x.device.createBindGroupLayout({label:"grid bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},...m.gridBuffers.map(((e,t)=>({binding:t+2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}))),{binding:12,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),this.computePipeline=x.device.createComputePipeline({label:"Grid compute pipeline",layout:x.device.createPipelineLayout({bindGroupLayouts:[this.computeBindGroupLayout]}),compute:{module:e,entryPoint:"computeMain"}}),this.computeBindGroup=x.device.createBindGroup({layout:this.computeBindGroupLayout,entries:[{binding:0,resource:{buffer:m.spheresBuffer}},{binding:1,resource:{buffer:m.atomicBuffer}},...m.gridBuffers.map(((e,t)=>({binding:t+2,resource:{buffer:e}}))),{binding:12,resource:{buffer:this.uniformBuffer}}]})}static#n(){return x.device.createShaderModule({label:"Grid compute shader",code:"\n        \nstruct Uniforms {\n    numSpheres: u32\n}\n\n@group(0) @binding(0) var<storage, read_write> positions: array<f32>;\n@group(0) @binding(1) var<storage, read_write> atomicCounter: array<atomic<u32>>;\n@group(0) @binding(2) var<storage, read_write> grid1: array<vec2u>;\n@group(0) @binding(3) var<storage, read_write> grid2: array<vec2u>;\n@group(0) @binding(4) var<storage, read_write> grid3: array<vec2u>;   \n@group(0) @binding(5) var<storage, read_write> grid4: array<vec2u>;    \n// @group(0) @binding(6) var<storage, read_write> grid5: array<vec2u>;    \n// @group(0) @binding(7) var<storage, read_write> colors: array<atomic<u32>>;    \n@group(0) @binding(12) var<uniform> uniforms: Uniforms;\n\nfn frac_sign(x: f32) -> f32 {\n    let f = x - floor(x);  // Get fractional part\n    return select(1.0, -1.0, f < 0.5);\n}\n\n@compute @workgroup_size(256)\nfn computeMain(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sphereID = u32(global_id.x);\n    if (sphereID >= uniforms.numSpheres) {\n        return;\n    }\n\n    let spherePos = vec3i(vec3f(positions[sphereID*3+0],positions[sphereID*3+1],positions[sphereID*3+2])+128);\n\n    if(spherePos.x<0||spherePos.x>=256||spherePos.y<0||spherePos.y>=256||spherePos.z<0||spherePos.z>=256)\n    {\n        return;\n    }\n\n    // let neighborOffsets = array<vec3f,8>(\n    //     vec3f(frac_sign(spherePos.x), 0.0, 0.0),\n    //     vec3f(frac_sign(spherePos.x), 0.0, frac_sign(spherePos.z)),\n    //     vec3f(frac_sign(spherePos.x), frac_sign(spherePos.y), 0.0),\n    //     vec3f(0.0, frac_sign(spherePos.y), 0.0),\n    //     vec3f(0.0, frac_sign(spherePos.y), frac_sign(spherePos.z)),\n    //     vec3f(0.0, 0.0, frac_sign(spherePos.z)),\n    //     vec3f(frac_sign(spherePos.x), frac_sign(spherePos.y), frac_sign(spherePos.z)),\n    //     vec3f(0,0,0)\n    // );\n    // for (var i = 0u; i < 8u; i++) {\n    //     let neighborPos = vec3i(spherePos+neighborOffsets[i]);\n\n    //     // Check if the neighbor cell is within grid bounds\n    //     if (neighborPos.x >= 0 && neighborPos.x < 256 &&\n    //         neighborPos.y >= 0 && neighborPos.y < 256 &&\n    //         neighborPos.z >= 0 && neighborPos.z < 256) {\n    //let gridIndex = neighborPos.x + neighborPos.y * 256 + neighborPos.z * 65536;\n    let gridIndex = spherePos.x + spherePos.y * 256 + spherePos.z * 65536;\n    let index = atomicAdd(&atomicCounter[gridIndex], 1);\n    // atomicStore(&colors[sphereID], index);\n\n    switch (index / 2u) { \n        case 0u: {\n            grid1[gridIndex][index % 2u] = sphereID; \n            break;\n        }\n        case 1u: {\n            grid2[gridIndex][index % 2u] = sphereID; \n            break;\n        }\n        case 2u: {\n            grid3[gridIndex][index % 2u] = sphereID; \n            break;\n        }\n        case 3u: {\n            grid4[gridIndex][index % 2u] = sphereID; \n            break;\n        }                                              \n        default: {\n            break;\n        }\n        //     }\n        // }\n    }\n}"})}static tick(e){x.device.queue.writeBuffer(this.uniformBuffer,0,new Uint32Array([m.NUM_SPHERES])),e.clearBuffer(m.atomicBuffer,0,67108864);const t=e.beginComputePass();t.setPipeline(this.computePipeline),t.setBindGroup(0,this.computeBindGroup),t.dispatchWorkgroups(Math.ceil(m.NUM_SPHERES/256)),t.end()}}class y{static computePipeline;static computeBindGroup;static computeUniformBuffer;static computeBindGroupLayout;static init(){this.computeUniformBuffer=x.device.createBuffer({size:12,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const e=this.#n();this.computeBindGroupLayout=x.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.computeBindGroup=x.device.createBindGroup({layout:this.computeBindGroupLayout,entries:[{binding:0,resource:{buffer:this.computeUniformBuffer}},{binding:1,resource:{buffer:m.oldSpheresBuffer}},{binding:2,resource:{buffer:m.spheresBuffer}}]}),this.computePipeline=x.device.createComputePipeline({label:"Movement compute pipeline",layout:x.device.createPipelineLayout({bindGroupLayouts:[this.computeBindGroupLayout]}),compute:{module:e,entryPoint:"computeMain"}})}static#n(){return x.device.createShaderModule({label:"Movement compute shader",code:"\nstruct Uniforms {\n    time: f32,\n    numSpheres: u32,\n    gravityMode: u32,\n}\n\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n@group(0) @binding(1) var<storage, read_write> oldPositions: array<f32>;\n@group(0) @binding(2) var<storage, read_write> positions: array<f32>;\n\n@compute @workgroup_size(256)\nfn computeMain(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let sphereID = u32(global_id.x);\n    if (global_id.x >= uniforms.numSpheres) {\n        return;\n    }\n    \n    var oldPos = vec3f(oldPositions[sphereID*3+0],oldPositions[sphereID*3+1],oldPositions[sphereID*3+2]);\n    var nowPos = vec3f(positions[sphereID*3+0],positions[sphereID*3+1],positions[sphereID*3+2]);\n\n    var gravityDir = vec3f(0,0,0);// -normalize(nowPos);\n    switch (uniforms.gravityMode)\n    {\n        case 0u: {\n            gravityDir = vec3f(0.0, 0.0, 0.0);\n            break;\n        }\n        case 1u: {\n            gravityDir = -normalize(nowPos);\n            break;\n        }\n        case 2u: {\n            let distSq = dot(nowPos, nowPos);\n            if (distSq > 100.0 * 100.0) {\n                gravityDir = -normalize(nowPos);\n            } else if (distSq < 95.0 * 95.0) {\n                gravityDir = normalize(nowPos);\n            }\n            break;\n        }\n        case 3u: {\n            let noY = vec3f(nowPos.x,0,nowPos.z);\n            let distSq = dot(noY, noY);\n            if (distSq > 100.0 * 100.0) {\n                gravityDir = -normalize(noY);\n            } else if (distSq < 95.0 * 95.0) {\n                gravityDir = normalize(noY);\n            }\n            gravityDir.y =sign(-nowPos.y);\n            gravityDir = normalize(gravityDir);\n            break;\n        }\n        default: {\n            gravityDir = vec3f(0.0, 0.0, 0.0);\n            break;\n        }\n        \n    }\n\n    let velocity = nowPos - oldPos;\n\n    oldPos = nowPos;\n\n    nowPos += velocity * 0.99;\n\n    nowPos += gravityDir * 0.0013888888888;\n    // nowPos *= 0.99;\n\n    oldPositions[sphereID*3+0] = oldPos.x;\n    oldPositions[sphereID*3+1] = oldPos.y;\n    oldPositions[sphereID*3+2] = oldPos.z;\n\n    positions[sphereID*3+0] = nowPos.x;\n    positions[sphereID*3+1] = nowPos.y;\n    positions[sphereID*3+2] = nowPos.z;\n}"})}static tick(e,t){x.device.queue.writeBuffer(this.computeUniformBuffer,0,new Float32Array([e,m.NUM_SPHERES])),x.device.queue.writeBuffer(this.computeUniformBuffer,8,new Uint32Array([c.gravityMode]));const i=t.beginComputePass();i.setPipeline(this.computePipeline),i.setBindGroup(0,this.computeBindGroup),i.dispatchWorkgroups(Math.ceil(m.NUM_SPHERES/256)),i.end()}}class b{static pipeline;static bindGroup;static bindGroupLayout;static uniformBuffer;static init(){this.uniformBuffer=x.device.createBuffer({size:208,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.bindGroupLayout=x.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),this.bindGroup=x.device.createBindGroup({layout:this.bindGroupLayout,entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]});const e=this.#r();this.pipeline=x.device.createRenderPipeline({label:"Camera pipeline",layout:x.device.createPipelineLayout({bindGroupLayouts:[this.bindGroupLayout]}),vertex:{module:e,entryPoint:"vertexMain",buffers:[{arrayStride:12,stepMode:"instance",attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]},{arrayStride:4,stepMode:"instance",attributes:[{shaderLocation:1,offset:0,format:"uint32"}]}]},fragment:{module:e,entryPoint:"fragmentMain",targets:[{format:navigator.gpu.getPreferredCanvasFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"}})}static#r(){return x.device.createShaderModule({label:"Spheres rendering shader",code:"\n\nstruct Uniforms {\n    translationMatrix: mat4x4f,\n    rotationMatrix: mat4x4f,\n    projectionMatrix: mat4x4f,\n    lightDirection: vec4f,\n}\n@binding(0) @group(0) var<uniform> uniforms: Uniforms;\n\nstruct VertexOutput {\n    @builtin(position) position: vec4f,\n    @location(0) @interpolate(flat) color: vec3f,\n    @location(1) uv: vec2f,\n    @location(2) @interpolate(flat) right: vec3f,\n    @location(3) @interpolate(flat) adjustedUp: vec3f,\n    @location(4) @interpolate(flat) toCamera: vec3f,\n    @location(5) @interpolate(flat) worldPos: vec3f,\n    @location(6) @interpolate(flat) transformedCenter: vec3f\n}\n\nconst colorPalette = array<vec3f, 16>(\n    vec3f(1.0, 1.0, 1.0),  // White\n    vec3f(0.0, 1.0, 0.0),  // Vibrant Green\n    vec3f(0.0, 0.0, 1.0),  // Vibrant Blue\n    vec3f(1.0, 1.0, 0.0),  // Vibrant Yellow\n    vec3f(1.0, 0.5, 0.0),  // Orange\n    vec3f(0.2, 1.0, 1.0),  // Cyan\n    vec3f(1.0, 0.0, 1.0),  // Magenta\n    vec3f(0.8, 0.8, 0.8),  // Light Gray\n    vec3f(0.5, 0.5, 0.5),  // Medium Gray\n    vec3f(0.3, 0.3, 0.3),  // Dark Gray\n    vec3f(1.0, 0.0, 0.0),  // Bright Red\n    vec3f(0.8, 0.0, 0.0),  // Medium Red\n    vec3f(0.6, 0.0, 0.0),  // Dark Red\n    vec3f(0.4, 0.0, 0.0),  // Darker Red\n    vec3f(0.2, 0.0, 0.0),  // Very Dark Red\n    vec3f(0.0, 0.0, 0.0)   // Black\n);                    struct FragmentOutput {\n    @location(0) color: vec4f,\n    // @builtin(frag_depth) depth: f32\n}\n\n@vertex\nfn vertexMain(\n    @builtin(vertex_index) vertexIndex: u32,\n    @builtin(instance_index) instanceIndex: u32,\n    @location(0) instancePosition: vec3f,\n    @location(1) colorIndex: u32\n) -> VertexOutput {\n    const positions = array<vec2f, 3>(\n        vec2<f32>(0.0,   0.5773502691896258),           // Top vertex: (0, 1/√3)\n        vec2<f32>(-0.5, -0.2886751345948129),         // Bottom left: (-1/2, -1/(2√3))\n        vec2<f32>(0.5,  -0.2886751345948129)           // Bottom right: (1/2, -1/(2√3))\n    );\n    \n    // UV coordinates for triangle vertices\n    const uvs = array<vec2f, 3>(\n        vec2<f32>(0.0,   0.5773502691896258),           // Top vertex: (0, 1/√3)\n        vec2<f32>(-0.5, -0.2886751345948129),         // Bottom left: (-1/2, -1/(2√3))\n        vec2<f32>(0.5,  -0.2886751345948129)           // Bottom right: (1/2, -1/(2√3))\n    );\n\n    var output: VertexOutput;\n    var localPos = vec3f(positions[vertexIndex], 0.0);\n    // Calculate direction from instance position to camera position\n    let cameraPos = -uniforms.translationMatrix[3].xyz;\n    let toCamera = normalize(cameraPos - instancePosition);\n    \n    // Create rotation matrix to face camera\n    let up = vec3f(0.0, 1.0, 0.0);\n    let right = normalize(cross(up, toCamera));\n    let adjustedUp = normalize(cross(toCamera, right));\n    \n    localPos = localPos * 3.464101615137754 * 0.5; // Scale manually as needed\n    \n    // Apply billboard rotation to local position\n    localPos = right * localPos.x + adjustedUp * localPos.y + toCamera * localPos.z;\n\n    // Apply translation\n    var worldPos = localPos + instancePosition;\n\n    // Apply view transform\n    var viewPos = uniforms.translationMatrix * vec4f(worldPos, 1.0);\n\n    // Apply rotation\n    var rotatedPos = uniforms.rotationMatrix * viewPos;\n\n    let pos = uniforms.projectionMatrix * rotatedPos;\n    output.transformedCenter = (uniforms.projectionMatrix *\n                                uniforms.rotationMatrix *\n                                uniforms.translationMatrix * \n                                vec4f(instancePosition, 1.0)).xyz;\n    // Apply projection\n    output.position = pos;\n    output.color = colorPalette[colorIndex]; // Use color from palette\n    output.uv = uvs[vertexIndex];\n    \n    // Pass billboard basis vectors to fragment shader\n    output.right = right;\n    output.adjustedUp = adjustedUp;\n    output.toCamera = toCamera;\n    output.worldPos = worldPos;\n    // output.fragmentPos = pos.xyz;\n    return output;\n}\n\n@fragment\nfn fragmentMain(\n    @location(0) @interpolate(flat) color: vec3f,\n    @location(1) uv: vec2f,\n    @location(2) @interpolate(flat) right: vec3f,\n    @location(3) @interpolate(flat) adjustedUp: vec3f,\n    @location(4) @interpolate(flat) toCamera: vec3f,\n    @location(5) @interpolate(flat) worldPos: vec3f,\n    @location(6) @interpolate(flat) transformedCenter: vec3f \n) -> FragmentOutput {\n    // Calculate distance from center of triangle\n    const center = vec2f(0.0, 0.0);\n    let dist = distance(uv, center);\n    \n    // Create circle mask\n    const radius = 0.2886751345948129; // Distance from center to edge of the triangle\n    if (dist > radius) {\n        discard;\n    }\n    const inverseRadius = 3.464101615137754; // 1.0 / radius\n    \n    // Calculate local normal for sphere shading\n    let localz = sqrt(1.0 - dist * dist * inverseRadius * inverseRadius);\n    let localNormal = vec3f(uv.x * inverseRadius, uv.y * inverseRadius, localz);\n    \n    // Transform local normal to world space\n    let worldNormal =\n        right * localNormal.x + \n        adjustedUp * localNormal.y + \n        toCamera * localNormal.z;\n\n    // Light direction in world space\n    let lightDir = normalize(uniforms.lightDirection.xyz);\n    let diffuse = max(dot(worldNormal, -lightDir), 0.0);\n    let ambient = 0.2;\n    let litColor = color * (diffuse + ambient);\n\n    // Correct depth calculation\n    let sphereOffset = localz * 3.464101615137754 * 0.25; // Offset from the sphere center in world units\n    let actualZ = transformedCenter.z - sphereOffset; // Adjust depth based on sphere surface position\n    \n    // Normalize depth to clip space (0-1) using near/far planes\n    const near = 0.1;\n    const far = 3000.0;\n    let depth = (actualZ - near) / (far - near);\n\n    return FragmentOutput(\n        vec4f(litColor, 1.0),\n        // depth\n    );\n}"})}static tick(e){x.device.queue.writeBuffer(this.uniformBuffer,0,new Float32Array(c.translationMatrix.values())),x.device.queue.writeBuffer(this.uniformBuffer,64,new Float32Array(c.rotationMatrix.values())),x.device.queue.writeBuffer(this.uniformBuffer,128,new Float32Array(c.projectionMatrix.values())),x.device.queue.writeBuffer(this.uniformBuffer,192,new Float32Array(m.lightDirection.values())),e.setPipeline(this.pipeline),e.setBindGroup(0,this.bindGroup),e.setVertexBuffer(0,m.spheresBuffer),e.setVertexBuffer(1,m.colorIndexBuffer),e.draw(3,m.NUM_SPHERES,0,0)}}class B{static resized=!1;static init(){g.loadScene0(),m.init(),m.loadSceneToBuffers(g.objects),y.init(),P.init(),v.init(),b.init()}static update(e){if(c.paused)return;if(0===m.NUM_SPHERES)return;this.resized&&(m.resize(),this.resized=!1);const t=x.device.createCommandEncoder();y.tick(e,t),P.tick(t),v.tick(t);const i=t.beginRenderPass({colorAttachments:[{view:x.context.getCurrentTexture().createView(),clearValue:{r:.1,g:.1,b:.1,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:m.depthTexture.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}});b.tick(i),i.end(),x.device.queue.submit([t.finish()])}}class x{static device;static context;static canvas;static async init(){if(!navigator.gpu)throw new Error("WebGPU not supported");const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("No appropriate GPUAdapter found");if(this.device=await e.requestDevice(),this.canvas=document.querySelector("#webgpu-canvas"),!this.canvas)throw new Error("Canvas not found");if(this.resizeCanvas(),window.addEventListener("resize",(()=>this.resizeCanvas())),this.context=this.canvas.getContext("webgpu"),!this.context)throw new Error("WebGPU context not found");const t=navigator.gpu.getPreferredCanvasFormat();this.context.configure({device:this.device,format:t,alphaMode:"premultiplied"})}static resizeCanvas(){this.canvas&&(this.canvas.width=window.innerWidth*window.devicePixelRatio,this.canvas.height=window.innerHeight*window.devicePixelRatio,B.resized=!0,c.updateProjectionMatrix())}}class S{static animationFrameId;static animationCallbacks=[];static lastTimestamp=0;static fpsCounter=document.getElementById("fps-counter");static frameCount=0;static totalFps=0;static startAnimation(e){if(this.animationCallbacks.push(e),!this.animationFrameId){const e=t=>{const i=(t-this.lastTimestamp)/1e3;this.lastTimestamp=t;const n=1/i;if(this.totalFps+=n,this.frameCount++,this.frameCount>=10){const e=this.totalFps/10;this.fpsCounter&&(this.fpsCounter.textContent=`FPS: ${Math.round(e)}`),this.frameCount=0,this.totalFps=0}for(const e of this.animationCallbacks)e(i);this.animationFrameId=requestAnimationFrame(e)};this.lastTimestamp=performance.now(),e(this.lastTimestamp)}}static stopAnimation(e){if(this.animationFrameId){const t=this.animationCallbacks.indexOf(e);t>-1&&this.animationCallbacks.splice(t,1),0===this.animationCallbacks.length&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=0,this.frameCount=0,this.totalFps=0)}}}!async function(){e.init(),await x.init(),B.init(),c.init(),S.startAnimation((e=>c.update(e))),S.startAnimation((e=>B.update(e))),S.startAnimation((t=>e.clearUpdate()))}(),window.SharedData=m})();